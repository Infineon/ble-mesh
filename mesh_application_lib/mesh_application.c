/*
 * $ Copyright 2016-YEAR Cypress Semiconductor $
 */

/** @file
  *
  * Mesh
  *
  * A mesh network uses LE advertisements to send messages between node.
  * The original data packet could be generated by a node itself, like Can-You-
  * See-Me packet, or could be received from outside via LE or wired interface.
  * The node sends the data packet using LE advertisement. When a node received
  * a message, if the message is for itself only, it performs the action specified
  * in the message; otherwise it rebroadcasts the same message. Since advertisement
  * packet delivery is not guaranteed, each message is broadcasted multiple times
  * - the repeat time and interval can be configured. Each node also makes sure
  * one message will only be handled once and only once at each node.
  *
  * This is a mesh sample application. This node implements a proxy interface
  * for a LE-capable device to connect with it. the device sends the
  * mesh command packets to this node using a LE connection. This node sends the
  * command packet out on behalf of the device - hence this node performs
  * proxy function for the device to the mesh network. The interface between
  * a proxy node and the device is up to the customers - the one here is
  * just an example.
  */

#undef WIN32

#include "sparcommon.h"
#include "wiced_bt_types.h"
#include "wiced_bt_ble.h"
#include "wiced_bt_cfg.h"
#include "wiced_bt_uuid.h"

#include "wiced_bt_mesh_model_defs.h"
#include "wiced_bt_mesh_models.h"
#include "wiced_bt_mesh_event.h"
#include "wiced_bt_mesh_provision.h"
#include "wiced_bt_mesh_app.h"
#include "wiced_bt_mesh_client.h"
#include "wiced_bt_mesh_core.h"
#ifdef MESH_DFU_SUPPORTED
#include "wiced_bt_mesh_dfu.h"
#endif
#ifdef PRIVATE_PROXY_SUPPORTED
#include "wiced_bt_mesh_private_proxy.h"
#endif
#include "wiced_bt_trace.h"
#include "mesh_application.h"
#include "hci_control_api.h"
#include "wiced_memory.h"
#if ( defined(CYW20735B0) || defined(CYW20735B1) || defined(CYW20835B1) )
#include "wiced_gki.h"
#endif
#include "wiced_bt_ota_firmware_upgrade.h"
#ifndef MESH_HOST_MODE
#include "wiced_hal_puart.h"
#endif
#ifdef CYW20706A2
#include "wiced_bt_hci_defs.h"
#else
#include "hcidefs.h"
#endif

#include "wiced_bt_factory_app_config.h"
#include "wiced_bt_stack.h"

#include "wiced_bt_l2c.h"
#include "wiced_bt_dev.h"
#if ( defined(CYW20706A2) || defined(CYW20719B1) || defined(CYW20719B0) || defined(CYW20721B1) || defined(CYW20735B0) || defined(CYW43012C0) )
#include "wiced_bt_app_common.h"
#endif

//#define _DEB_DELAY_START_SEC 10

#ifdef _DEB_DELAY_START_SEC
#include "wiced_timer.h"
#endif


#ifdef ENABLE_BT_SPY_LOG
#include "cyhal.h"
#include "cybt_debug_uart.h"
#endif

#if ( defined(MESH_HOST_MODE) && !defined(WIN32) )
#include "cybt_platform_config.h"
#include "cybsp_types.h"
#include "cybt_result.h"
#define CYBSP_BAUD_RATE_FW_DOWNLOAD 115200
#define CYBSP_CONTROLLER_FEATURE_BAUD_RATE 115200

#include "cybt_platform_config.h"
#include "cybsp_types.h"

#include "mesh_platform_utils.h"

#include "p_256_ecc_pp.h"


extern wiced_bt_cfg_settings_t wiced_bt_cfg_settings;
extern const cybt_platform_config_t bt_platform_cfg_settings;

//extern cybt_result_t cybt_debug_uart_init(uint32_t baud_rate, cybt_debug_uart_data_handler_t p_data_handler);
#endif

// Comment out next line if we don't want to support GATT provisioning
#define MESH_SUPPORT_PB_GATT

// If defined then all NVRAM operations are executed on MCU via WICED-HCI
//#define MESH_APPLICATION_MCU_MEMORY

#ifdef MESH_APPLICATION_MCU_MEMORY
uint16_t mesh_application_mcu_memory_read(uint16_t id, uint16_t buf_len, uint8_t *p_buf);
uint16_t mesh_application_mcu_memory_write(uint16_t id, uint16_t data_len, const uint8_t *p_data);
wiced_result_t mesh_application_process_hci_cmd(uint16_t opcode, const uint8_t *p_data, uint16_t data_len);
wiced_result_t mesh_application_send_hci_event(uint16_t opcode, const uint8_t *p_data, uint16_t data_len);
#endif

#if defined(CYW20719B0)
void wiced_bt_set_pairable_mode(uint8_t allow_pairing, uint8_t connect_only_paired);
#endif

/******************************************************
 *          Constants
 ******************************************************/
// The power table is 3, -1, -5, -9
#define TX_DBM   4

#if 0
#if !defined(CYW43012C0) && !defined(CYW20706A2) && !defined(CYW20719B0) && !defined (MESH_HOST_MODE)
extern wiced_platform_button_config_t platform_button[];
#endif
#endif


#define MESH_APP_TIMEOUT_IN_SECONDS   			  1u

// if defined then prints mesh stats every _DEB_PRINT_MESH_STATS seconds
#define _DEB_PRINT_MESH_STATS 10

// if defined then dump wiced bt buffer statistics on every _DEB_PRINT_BUF_USE seconds to monitor buffer usage
//#define _DEB_PRINT_BUF_USE  5


/******************************************************
 *          Structures
 ******************************************************/

extern wiced_bt_mesh_core_config_t          mesh_config;
extern wiced_bt_cfg_ble_scan_settings_t     wiced_bt_cfg_scan_settings;

#pragma pack(1)
#ifndef PACKED
#define PACKED
#endif

// represents data saved in the NVRAM with index mesh_nvm_idx_seq
typedef PACKED struct
{
    uint32_t    seq;        // self SEQ
    uint16_t    size;       // Size of the RPL - number of RPL items
} mesh_app_rpl_init_t;

#define MESH_APP_RPL_ITEM_PREV_IVI_FLAG 0x8000
// Represents one RPL entry in the NVRAM
typedef PACKED struct
{
    uint16_t    addr;       // Bit MESH_APP_RPL_ITEM_PREV_IVI_FLAG means previous IVI
    uint8_t     seq[3];     // latest SEQ for SRC addr
} mesh_app_rpl_item_t;

#pragma pack()

// current value of own SEQ and RPL size
static mesh_app_rpl_init_t mesh_app_rpl_init = { 0 };
#ifdef CYW20706A2
// On 20706 we keep all RPL entries in the one NVRAM index
static mesh_app_rpl_item_t *mesh_app_rpl_items = NULL;
#endif

// Application can set this handler to process if it implements models layer (including configuration).
wiced_bt_mesh_core_received_msg_handler_t p_app_model_message_handler = NULL;

wiced_bt_mesh_core_received_msg_handler_t p_proxy_status_message_handler = NULL;

// Application has to assign config pointer to that variable at the startup
extern wiced_bt_cfg_settings_t* p_wiced_bt_mesh_cfg_settings;

#if defined(LOW_POWER_NODE) && (LOW_POWER_NODE == 1)
// Poll interval and poll time in the Fast Polling state which starts at the provisioning.
// In that state the LPN uses short poll timeout 1 second(MESH_APP_FAST_POLL_TIMEOUT) during 30 seconds(MESH_APP_FAST_POLL_TIME) after provisioning.
#define MESH_APP_FAST_POLL_TIMEOUT  1000
#define MESH_APP_FAST_POLL_TIME     30000

// The time when LPN stops the Fast Polling state.
// Non-0 value means the node is in the Fast Polling state.
uint64_t mesh_app_fast_polling_stop_time = 0;
#endif

/******************************************************
 *          Function Prototypes
 ******************************************************/
// Local functions
#if 0
static void                     mesh_interrupt_handler(void* user_data, uint8_t value);
#endif

static uint32_t                 mesh_nvram_access(wiced_bool_t write, int inx, uint8_t* node_info, uint16_t len, wiced_result_t *p_result);
static uint8_t                  mesh_fault_test(uint8_t element, uint8_t test_id, uint16_t company_id, uint8_t fault_array_size, uint8_t *fault_array);
static void                     mesh_state_changed_cb(wiced_bt_mesh_core_state_type_t type, wiced_bt_mesh_core_state_t *p_state);
static void                     mesh_adv_report(wiced_bt_ble_scan_results_t *p_scan_result, uint8_t *p_adv_data);
static uint8_t                  mesh_get_number_of_elements(uint16_t model_id);
void                            mesh_start_stop_scan_callback(wiced_bool_t start, wiced_bool_t is_active);

static wiced_bt_mesh_core_received_msg_handler_t mesh_app_message_handler_callback(uint16_t company_id, uint16_t opcode,
																			uint16_t *p_model_id, uint8_t* p_rpl_delay);
static wiced_bool_t 			mesh_app_publication_callback(uint8_t elem_idx, uint16_t company_id, uint16_t model_id, uint16_t period);
static void  					mesh_app_timer_callback(wiced_timer_callback_t count);

static wiced_bool_t             mesh_application_seq_save(wiced_bt_mesh_core_state_seq_t *p_seq);
static wiced_bool_t             mesh_application_seq_init(void);
static wiced_bool_t             mesh_application_rpl_clr(void);

#define SECURE_PROVISIONING
#ifdef SECURE_PROVISIONING
static void mesh_app_process_oob_get(wiced_bt_mesh_provision_device_oob_request_data_t *p_data);
static void mesh_app_provision_message_handler(uint16_t event, void *p_data);
#endif

#ifdef MESH_HOMEKIT_COMBO_APP
extern void mesh_provisioning_state_changed(wiced_bool_t provisioned);
extern void homekit_factory_reset();
#endif



extern uint16_t wiced_bt_mesh_core_lpn_get_friend_addr(void);

/******************************************************
 *          Variables Definitions
 ******************************************************/
// NVM index for SEQ
uint16_t mesh_nvm_idx_seq;
uint8_t  mesh_notify_host_seq_change = 1;
uint8_t device_uuid[16];
#ifdef SECURE_PROVISIONING
// Static private key should be written in static section flash during manufacturing
uint8_t static_private_key[WICED_BT_MESH_PROVISION_PRIV_KEY_LEN];
uint8_t static_private_key_len = 0;

// Static OOB Data should be written in static section flash during manufacturing
uint8_t static_oob_data[16];
uint8_t static_oob_data_len = 0;
#endif

#define STATIC_UUID
#ifdef STATIC_UUID
// In real product, Static OOB Data should be written in static section flash during manufacturing
uint8_t static_uuid[16] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
#endif

#ifdef PTS
#define STATIC_OOB_PUB_KEY
#endif
#ifdef STATIC_OOB_PUB_KEY
// Use hardcoded PTS default priv key. In real app it will be generated once and written into OTP memory
uint8_t pb_priv_key[WICED_BT_MESH_PROVISION_PRIV_KEY_LEN] = { 0x52, 0x9A, 0xA0, 0x67, 0x0D, 0x72, 0xCD, 0x64, 0x97, 0x50, 0x2E, 0xD4, 0x73, 0x50, 0x2B, 0x03, 0x7E, 0x88, 0x03, 0xB5, 0xC6, 0x08, 0x29, 0xA5, 0xA3, 0xCA, 0xA2, 0x19, 0x50, 0x55, 0x30, 0xBA };
#else
uint8_t *pb_priv_key = NULL;
#endif

#ifdef MESH_HOST_MODE
EC curve_p256;
extern EC *p_curve_p256;

#endif

//WICED_TRUE is we are provisioner
wiced_bool_t mesh_config_client = WICED_FALSE;
wiced_bool_t node_authenticated = WICED_FALSE;
wiced_bool_t pb_gatt_in_progress = WICED_FALSE;

// NVRAM IDs used by mesh models library
uint16_t wiced_bt_mesh_scene_register_nvram_id;
uint16_t wiced_bt_mesh_scene_nvram_id_start;
uint16_t wiced_bt_mesh_scene_nvram_id_end;
uint16_t wiced_bt_mesh_scheduler_nvram_id_start;
uint16_t wiced_bt_mesh_default_trans_time_nvram_id_start;
uint16_t wiced_bt_mesh_power_level_nvram_id_start;
uint16_t wiced_bt_mesh_power_onoff_nvram_id_start;
uint16_t wiced_bt_mesh_light_lightness_nvram_id_start;
uint16_t wiced_bt_mesh_light_xyl_nvram_id_start;
uint16_t wiced_bt_mesh_light_ctl_nvram_id_start;
uint16_t wiced_bt_mesh_light_hsl_nvram_id_start;
uint16_t wiced_bt_mesh_light_lc_run_nvram_id_start;
uint16_t wiced_bt_mesh_light_lc_nvram_id_start;

uint8_t  wiced_bt_mesh_scene_max_num;
uint8_t  wiced_bt_mesh_scheduler_events_max_num;

// app timer
static wiced_timer_t mesh_app_timer;

static wiced_bt_mesh_app_non_conn_adv_handler_t p_non_conn_adv_handler = NULL;

#define mesh_app_wiced_hal_delete_nvram wiced_hal_delete_nvram

// 20706 has different definition for read/write nvram
#if !defined(CYW20706A2)
#define mesh_app_wiced_hal_write_nvram wiced_hal_write_nvram
#define mesh_app_wiced_hal_read_nvram wiced_hal_read_nvram
#else
uint16_t mesh_app_wiced_hal_write_nvram(uint16_t vs_id, uint16_t data_length, uint8_t* p_data, wiced_result_t* p_status)
{
    return (uint16_t)wiced_hal_write_nvram((uint8_t)vs_id, (uint8_t)data_length, p_data, p_status);
}
uint16_t mesh_app_wiced_hal_read_nvram(uint16_t vs_id, uint16_t data_length, uint8_t* p_data, wiced_result_t* p_status)
{
    return (uint16_t)wiced_hal_read_nvram((uint8_t)vs_id, (uint8_t)data_length, p_data, p_status);
}
#endif

wiced_bt_mesh_core_hal_api_t mesh_app_hal_api =
{
    .rand_gen_num_array = mesh_util_get_rand_gen_num_array,
    .get_pseudo_rand_number = mesh_util_get_pseudo_rand_number,
    .rand_gen_num = mesh_util_get_rand_gen_num,
    .wdog_reset_system = mesh_util_wdog_reset_system,
    .delete_nvram = mesh_app_wiced_hal_delete_nvram,
    .write_nvram = mesh_app_wiced_hal_write_nvram,
    .read_nvram = mesh_app_wiced_hal_read_nvram,
    .aes_encrypt = mesh_app_aes_encrypt
};

/******************************************************
 *               Function Definitions
 ******************************************************/
#ifndef MESH_HOST_MODE
 /*
 *  Entry point to the application. Set device configuration and start BT
 *  stack initialization.  The actual application initialization will happen
 *  when stack reports that BT device is ready.
 */
#ifndef MESH_HOMEKIT_COMBO_APP
#if (defined(CYW20719B0) || defined(CYW20719B1) || defined(CYW20721B1) ||  defined(CYW20706A2) || (defined (MESH_HOST_MODE) && !defined(STACK_INSIDE_FREE_RTOS)))
APPLICATION_START()
#else
void application_start(void)
#endif
#else // MESH_HOMEKIT_COMBO_APP
void mesh_application_start()
#endif
{

#if defined(MESH_HOST_MODE)
#if defined(WIN32)
    mesh_app_hci_init();
#else

#endif
#endif

#ifndef WICEDX_LINUX
    // If application wants to control the hardware, call appropriate initialization function.
    // Otherwise use default processing of the mesh application library.
    if (wiced_bt_mesh_app_func_table.p_mesh_app_hw_init != NULL)
    {
        wiced_bt_mesh_app_func_table.p_mesh_app_hw_init();
    }
    else
    {
        /* Configure buttons available on the platform */
#if defined(CYW20706A2)
        wiced_hal_gpio_configure_pin(WICED_GPIO_BUTTON, WICED_GPIO_BUTTON_SETTINGS(GPIO_EN_INT_BOTH_EDGE), WICED_GPIO_BUTTON_DEFAULT_STATE);
        wiced_hal_gpio_register_pin_for_interrupt(WICED_GPIO_BUTTON, mesh_interrupt_handler, NULL);
#elif defined(CYW43012C0) || defined (MESH_HOST_MODE)
#elif (defined(CYW20735B0) || defined(CYW20719B0) || defined(CYW20721B0))
        wiced_hal_gpio_register_pin_for_interrupt(WICED_GPIO_PIN_BUTTON, mesh_interrupt_handler, NULL);
        wiced_hal_gpio_configure_pin(WICED_GPIO_PIN_BUTTON, WICED_GPIO_BUTTON_SETTINGS, GPIO_PIN_OUTPUT_LOW);
#else
        wiced_platform_register_button_callback(WICED_PLATFORM_BUTTON_1, mesh_interrupt_handler, NULL, GPIO_EN_INT_BOTH_EDGE);
#endif
    }
#ifndef MESH_HOMEKIT_COMBO_APP
    // Register call back and configuration with stack
#ifdef MESH_HOST_MODE

    //Initialize SMP curve
    p_curve_p256 = &curve_p256;

    // Register call back and configuration with stack
    wiced_bt_stack_init(mesh_management_cback, &wiced_bt_cfg_settings);

    /* Create a  10K heap, make it the default heap.  */
    p_mesh_heap = wiced_bt_create_heap("mesh_app", NULL, 10*1024, NULL, WICED_TRUE);


#else
    wiced_bt_stack_init(mesh_management_cback, &wiced_bt_cfg_settings, wiced_bt_cfg_buf_pools);
#endif
#endif
#endif
    // Currently we can support up to 4 network keys.
    wiced_bt_mesh_core_net_key_max_num = 4;
    wiced_bt_mesh_core_app_key_max_num = 8;
    wiced_bt_mesh_scene_max_num = 10;
    wiced_bt_mesh_scheduler_events_max_num = 16; // PTS test uses index 15 (MMDL/SR/SCHS/BV-01-C )

    // setup NVRAM IDs which will be used by core and models
    mesh_setup_nvram_ids();

    //WICED_BT_TRACE("Mesh Start: %d.%d.%d.%d\n", WICED_SDK_MAJOR_VER, WICED_SDK_MINOR_VER, WICED_SDK_REV_NUMBER, WICED_SDK_BUILD_NUMBER);
}
#endif
#ifdef _DEB_DELAY_START_SEC
wiced_timer_t    mesh_delay_start_timer;
void mesh_delay_start_timer_callback(TIMER_PARAM_TYPE arg)
{
#ifdef MESH_APPLICATION_MCU_MEMORY
    mesh_application_send_hci_event(HCI_CONTROL_EVENT_DEVICE_STARTED, NULL, 0);
#else
    mesh_application_init();
#endif
}

void mesh_delay_start_init(void)
{
    memset(&mesh_delay_start_timer, 0, sizeof(wiced_timer_t));
    wiced_init_timer(&mesh_delay_start_timer, mesh_delay_start_timer_callback, 0, WICED_SECONDS_TIMER);
    wiced_start_timer(&mesh_delay_start_timer, _DEB_DELAY_START_SEC);
}

#endif



#ifndef PTS
extern void utilslib_delayUs(uint32_t delay);
void mesh_application_gen_uuid(uint8_t *uuid)
{
#if !defined( WICEDX_LINUX) && !defined(MESH_HOST_MODE)
    int                 i;
    // TRNG might not work while chip is warming up.  Wait 2 seconds.
    // This happens only once during the very first power up, so should not be a problem.
    for (i = 0; i < 2000; i++)
    {
        utilslib_delayUs(1000);
        wiced_hal_wdog_restart();
    }
#endif
    // Generate version 4 UUID (Random) per rfc4122:
    // - Set the two most significant bits(bits 6 and 7) of the
    //   clock_seq_hi_and_reserved to zero and one, respectively.
    // - Set the four most significant bits(bits 12 through 15) of the
    //   time_hi_and_version field to the 4 - bit version number.
    // - Set all the other bits to randomly(or pseudo - randomly) chosen values.
    *(uint32_t*)&uuid[0] =  mesh_util_get_rand_gen_num();
    *(uint32_t*)&uuid[4] = mesh_util_get_rand_gen_num();
    *(uint32_t*)&uuid[8] = mesh_util_get_rand_gen_num();
    *(uint32_t*)&uuid[12] = mesh_util_get_rand_gen_num();
    // The version field is 4.
    uuid[6] = (uuid[6] & 0x0f) | 0x40;
    // The variant field is 10B
    uuid[8] = (uuid[8] & 0x3f) | 0x80;

#ifdef EMBEDDED_PROV_UUID_MAGIC_NUBMER
    *(uint64_t*)&uuid[4] = EMBEDDED_PROV_UUID_MAGIC_NUBMER;

    if (mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_REMOTE_PROVISION_SRV) > 0)
        uuid[4] |= CY_MAGIC_RPR_SUPPORTED;
    else
        uuid[4] &= ~CY_MAGIC_RPR_SUPPORTED;

    if ((mesh_config.features & WICED_BT_MESH_CORE_FEATURE_BIT_RELAY) != 0)
        uuid[4] |= CY_MAGIC_RELAY_SUPPORTED;
    else
        uuid[4] &= ~CY_MAGIC_RELAY_SUPPORTED;
#endif
}
#endif

void mesh_application_factory_reset(void)
{
    // uncomment following lines to delete UUID from the NV. This will change UUID on factory reset.
    wiced_result_t result;
    mesh_nvram_access(WICED_TRUE, NVRAM_ID_APP_START, NULL, 0, &result);

    wiced_bt_mesh_core_reset();

    WICED_BT_TRACE("mesh_application_factory_reset: done\r\n");
    if (wiced_bt_mesh_app_func_table.p_mesh_app_factory_reset)
    {
        wiced_bt_mesh_app_func_table.p_mesh_app_factory_reset();
    }

    node_authenticated = WICED_FALSE;
    pb_gatt_in_progress = WICED_FALSE;
}

// If uuid_len == 16 then assigns UUID to the node. It does factory reset. And it does factory reset
void mesh_application_hard_reset(uint8_t *uuid, uint8_t uuid_len)
{
    wiced_result_t  result;
    if (uuid_len == 16)
    {
        if (16 != mesh_nvram_access(WICED_TRUE, NVRAM_ID_LOCAL_UUID, uuid, uuid_len, &result))
        {
            WICED_BT_TRACE("failed to set UUID result:%x\n", result);
        }
    }
    mesh_application_factory_reset();
}

void mesh_ota_firmware_upgrade_status_callback(uint8_t status)
{
    WICED_BT_TRACE("mesh_ota_firmware_upgrade_status_callback: status:%d\n", status);

    // Due to a FW bug in 20706A2, the chip may crash if too many advertisements arrive
    // while we are reading the SFLASH.  To work around the problem, disable for the duration
    // while we are reading.
    // It is useful for all other platforms too for better FW buffer pool utilization for receiving adverts.
    if (status == OTA_FW_UPGRADE_STATUS_VERIFICATION_START)
        mesh_start_stop_scan_callback(WICED_FALSE, WICED_FALSE);
    else if (status == OTA_FW_UPGRADE_STATUS_ABORTED)
        mesh_start_stop_scan_callback(WICED_TRUE, WICED_FALSE);
}

// This function is executed in the BTM_ENABLED_EVT management callback.
void mesh_application_init(void)
{
    wiced_result_t            result;
    wiced_bt_mesh_core_init_t init = { 0 };
    uint16_t                  nvm_idx_cfg_data_before_init;
#ifdef  CERTIFICATE_BASED_PROVISIONING_SUPPORTED
    uint8_t                   buffer[(6 * 2) + 16 + 1]; /* MESH_URI_MAX_LEN + 1 is a URI provisioning record with terminating /0 byte */
    BOOL8                    av_uuid = FALSE;
    BOOL8                    av_private_key = FALSE;
#endif
    WICED_BT_TRACE("## mesh_application_init ##\n\n");

    mesh_util_print_heap_usage();
    wiced_bt_mesh_core_set_hal_api(&mesh_app_hal_api);

// On 20719B0 wiced_init_timer() fails if it called from APPLICATION_START.
#ifndef WICEDX_LINUX
#ifdef WICED_BT_TRACE_ENABLE
    mesh_app_timer_init();
#endif
#endif

#if (MESH_MODELS_DEBUG_TRACES)
    wiced_bt_mesh_models_set_trace_level(WICED_BT_MESH_CORE_TRACE_DEBUG);
#endif

#if (MESH_CORE_DEBUG_TRACES)
    // Set Debug trace level for all modules but Info level for CORE_AES_CCM module
    wiced_bt_mesh_core_set_trace_level(WICED_BT_MESH_CORE_TRACE_FID_ALL, WICED_BT_MESH_CORE_TRACE_DEBUG);
    wiced_bt_mesh_core_set_trace_level(WICED_BT_MESH_CORE_TRACE_FID_CORE_AES_CCM, WICED_BT_MESH_CORE_TRACE_INFO);
#endif

#ifndef MESH_HOMEKIT_COMBO_APP
    /* Initialize wiced app */
#if (!defined(CYW20735B1) && !defined(CYW20835B1) && !defined(CYW20819A1) && !defined(CYW20719B2) && !defined(CYW20721B2) && !defined (MESH_HOST_MODE))
    wiced_bt_app_init();
#endif

#endif

#ifndef WICEDX_LINUX
#ifndef MESH_HOMEKIT_COMBO_APP
    mesh_app_gatt_init();
    wiced_bt_set_pairable_mode(WICED_FALSE, WICED_FALSE);
#endif // MESH_HOMEKIT_COMBO_APP
#endif
    //remember if we are provisioner (config client)
    mesh_config_client = mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_CONFIG_CLNT) > 0 ? WICED_TRUE : WICED_FALSE;

    // initialize core
    // each node shall be assigned a 128-bit UUID known as the Device UUID.
    // Device manufacturers shall follow the standard UUID format and generation
    // procedure to ensure the uniqueness of each Device UUID.
#ifdef PTS
    // for PTS testing device_uuid is local bda with hardcoded(0x0f) remaining bytes
    wiced_bt_dev_read_local_addr(init.non_provisioned_bda);

#ifdef MESH_HOST_MODE
    // 20829 does not have static section to store BD_DEVICE_ADDRESS
    // This is a temporary solution to hardcode the BD_ADDR
    uint8_t local_bda[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66 };
    memcpy(init.non_provisioned_bda, local_bda, BD_ADDR_LEN);
#endif
    memcpy(init.provisioned_bda, init.non_provisioned_bda, sizeof(wiced_bt_device_address_t));
    memcpy(&init.device_uuid[0], init.non_provisioned_bda, 6);
    memset(&init.device_uuid[6], 0x0f, 16 - 6);
    // Some PTS tests require retrans count bigger then 1 for multicast addr. Default value is 1
    extern uint8_t wiced_bt_core_lower_transport_seg_trans_cnt_group;
    wiced_bt_core_lower_transport_seg_trans_cnt_group = 3;
#else
    if (mesh_nvram_access(WICED_FALSE, NVRAM_ID_LOCAL_UUID, init.device_uuid, 16, &result) != 16)
    {
#ifdef HARDCODED_UUID
        // Set hardcoded UUID - it can be needed for Directed Forwarding testing of the Low Power node
        uint8_t hardcoded_uuid[] = { HARDCODED_UUID };
        memcpy(init.device_uuid, hardcoded_uuid, sizeof(hardcoded_uuid));
        WICED_BT_TRACE_ARRAY(hardcoded_uuid, sizeof(hardcoded_uuid), "hardcoded_uuid:");
#else
#ifndef MESH_HOST_MODE
        // This is the first time for this app is running after the factory reset.
        // Check if UUID data have been configured in the factory
        uint16_t record_size;
        if (wiced_bt_factory_config_read(WICED_BT_FACTORY_CONFIG_ITEM_UUID, init.device_uuid, sizeof(init.device_uuid), 0, &record_size) != sizeof(init.device_uuid))
#endif
        {
            // Not programmed at factory, generate UUID
            mesh_application_gen_uuid(init.device_uuid);
        }
#ifdef  CERTIFICATE_BASED_PROVISIONING_SUPPORTED
        else
        {
            av_uuid = TRUE; //only if it was not randomly generated!
        }
#endif
#endif
        // Save UUID in the NVRAM for future use
        if (16 != mesh_nvram_access(WICED_TRUE, NVRAM_ID_LOCAL_UUID, init.device_uuid, 16, &result))
        {
            WICED_BT_TRACE("failed to save UUID result:%x UUID:\n", result);
        }
    }
#ifdef  CERTIFICATE_BASED_PROVISIONING_SUPPORTED
    else
    {
        /* in case if UUID is  present in static memory, set valid flag for choice to support certificate in OOB */
        uint16_t record_size;
        if (wiced_bt_factory_config_read(WICED_BT_FACTORY_CONFIG_ITEM_UUID, buffer, sizeof(init.device_uuid), 0, &record_size) == sizeof(init.device_uuid))
        {
            /* if NVRAM contains the same information as factory configuration */
            if (memcmp(buffer, init.device_uuid, sizeof(init.device_uuid)) == 0)
            {
                av_uuid = TRUE;
            }
        }
    }
#endif
#if defined(SECURE_PROVISIONING) || defined(CERTIFICATE_BASED_PROVISIONING_SUPPORTED)
    // Check if we have Static Private Key programmed at the factory
    {
        uint16_t record_size;
        static_private_key_len = wiced_bt_factory_config_read(WICED_BT_FACTORY_CONFIG_ITEM_PRIVATE_KEY, static_private_key, sizeof(static_private_key), 0, &record_size);
        if (static_private_key_len != 0)
        {
            WICED_BT_TRACE_ARRAY(static_private_key, static_private_key_len, "static private key:");
#ifdef  CERTIFICATE_BASED_PROVISIONING_SUPPORTED
            av_private_key = TRUE;
#endif
        }
        // Check if we have OOB Static Data programmed at the factory
        static_oob_data_len = wiced_bt_factory_config_read(WICED_BT_FACTORY_CONFIG_ITEM_OOB_STATIC_DATA, static_oob_data, sizeof(static_oob_data), 0, &record_size);
        if (static_oob_data_len != 0)
        {
            WICED_BT_TRACE_ARRAY(static_oob_data, static_oob_data_len, "static OOB:");
        }
#endif
    }
    // First 6 bytes and last 6 are random. Use them for BT addresses
    memcpy(init.non_provisioned_bda, init.device_uuid, 6);
    memcpy(init.provisioned_bda, &init.device_uuid[10], 6);
    /* Valid static random address should have 2 most significant bits set to 1 */
    init.non_provisioned_bda[0] |= 0xc0;
    init.provisioned_bda[0] |= 0xc0;
#endif
    WICED_BT_TRACE_ARRAY(init.device_uuid, 16, "UUID:");
    memcpy(device_uuid, &init.device_uuid, 16);
    //assign config pointer to that variable at the startup. remote_provision_server uses it
    p_wiced_bt_mesh_cfg_settings = &wiced_bt_cfg_settings;

#ifdef MESH_SUPPORT_PB_GATT
    mesh_config.features |= WICED_BT_MESH_CORE_FEATURE_BIT_PB_GATT;
#endif
#ifdef  CERTIFICATE_BASED_PROVISIONING_SUPPORTED
    /* Certificate based provisioning works only when UUID and private key are available in static memory */
    /* The reason for it - certificate is created with known UUID and public key that is reciprocal of private key */
    uint16_t record_size = 0;
    if ((av_private_key == TRUE) && (av_uuid == TRUE))
    {
        mesh_config.oob |= WICED_BT_MESH_CORE_OOB_BIT_CERTIFICATE;
        /*
         * checking if static section of memory contains provisioning records.
         * Reading only one byte at the begining to test in case of certificate or URI
         */
        if ((wiced_bt_factory_config_read(WICED_BT_FACTORY_CONFIG_ITEM_DEVICE_CERTIFICATE, buffer, 1, 0, &record_size) != 0)
        || (wiced_bt_factory_config_read(WICED_BT_FACTORY_CONFIG_ITEM_BASE_URI, buffer, 1, 0, &record_size) != 0))
        {
            WICED_BT_TRACE("device has certificate or URI as provisioning record in static memory\n");
            mesh_config.oob |= WICED_BT_MESH_CORE_OOB_BIT_RECORD;
        }
    }
    WICED_BT_TRACE("## mesh_application_init [oob]=:%d ##\n", mesh_config.oob);
#endif
#if defined(LOW_POWER_NODE) && (LOW_POWER_NODE == 1)
    // Reset Fast Polling state
    mesh_app_fast_polling_stop_time = 0;
#endif

    init.p_config_data = &mesh_config;
    init.callback = mesh_app_message_handler_callback;
    init.pub_callback = mesh_app_publication_callback;
    init.proxy_send_callback = mesh_app_proxy_gatt_send_cb;
    init.adv_send_callback = mesh_app_adv_send_callback;
    init.nvram_access_callback = mesh_nvram_access;
    init.fault_test_cb = mesh_fault_test;
    init.attention_cb = wiced_bt_mesh_app_func_table.p_mesh_app_attention;
    init.state_changed_cb = mesh_state_changed_cb;
    init.scan_callback = mesh_start_stop_scan_callback;
    // Remember wiced_bt_mesh_core_nvm_idx_cfg_data. Core initialization can change it if detects it is changed after OTA FW upgrade
    nvm_idx_cfg_data_before_init = wiced_bt_mesh_core_nvm_idx_cfg_data;
    result = wiced_bt_mesh_core_init(&init);
    if (result != WICED_BT_SUCCESS && result != WICED_BT_PENDING)
    {
        WICED_BT_TRACE("mesh_application_init: wiced_bt_mesh_core_init failed. result=%x\n", result);
        mesh_application_factory_reset();
        return;
    }
    node_authenticated = (result == WICED_BT_SUCCESS) ? WICED_TRUE : WICED_FALSE;

    // If node is provisioned and wiced_bt_mesh_core_nvm_idx_cfg_data is changed after OTA FW upgrade then update mesh_nvm_idx_seq too
    if (node_authenticated && (nvm_idx_cfg_data_before_init != wiced_bt_mesh_core_nvm_idx_cfg_data))
        mesh_nvm_idx_seq += wiced_bt_mesh_core_nvm_idx_cfg_data - nvm_idx_cfg_data_before_init;

    //WICED_BT_TRACE("mesh_application_init: authenticated:%d nvm_idx_cfg_data:%x/%x nvm_idx_seq:%x\n", node_authenticated, nvm_idx_cfg_data_before_init, wiced_bt_mesh_core_nvm_idx_cfg_data, mesh_nvm_idx_seq);


#ifndef WICEDX_LINUX
    mesh_app_gatt_db_init(node_authenticated);

    // Initialize own SEQ and RPL
    if (!mesh_application_seq_init())
        mesh_application_factory_reset();

#if OTA_FW_UPGRADE
    // Initialize OTA FW upgrade
    if (!wiced_ota_fw_upgrade_init(NULL, mesh_ota_firmware_upgrade_status_callback, mesh_ota_firmware_upgrade_send_data_callback))
    {
        WICED_BT_TRACE("mesh_application_init: wiced_ota_fw_upgrade_init failed\n");
    }
#endif
#endif

#if defined (SECURE_PROVISIONING) || defined ( CERTIFICATE_BASED_PROVISIONING_SUPPORTED)
    if (static_private_key_len != 0 || static_oob_data_len != 0)
    {
        wiced_bt_mesh_provision_capabilities_data_t provision_caps;

        memset(&provision_caps, 0, sizeof(provision_caps));

        // This application supports Static Private Key/Static OOB Data. Register event handler with mesh_app library.
        if (static_private_key_len != 0)
            wiced_bt_mesh_app_provision_server_init(static_private_key, mesh_app_provision_message_handler);
        else
        wiced_bt_mesh_app_provision_server_init(pb_priv_key, mesh_app_provision_message_handler);

        /* Presense of the private key in the static memory isn't good indication that public key is available as OOB */
        /* Using this only as circumstantial evidence. Could be improved upon */
        provision_caps.pub_key_type      = static_private_key_len != 0 ? WICED_BT_MESH_PROVISION_CAPS_PUB_KEY_TYPE_AVAILABLE : 0;
        provision_caps.static_oob_type   = static_oob_data_len != 0 ? WICED_BT_MESH_PROVISION_CAPS_STATIC_OOB_TYPE_AVAILABLE : 0;
        provision_caps.output_oob_action = 0;
        provision_caps.output_oob_size = 0;
        provision_caps.input_oob_action = 0;
        provision_caps.input_oob_size = 0;
        memset(provision_caps.static_oob, 0, 16*sizeof(uint8_t));

        wiced_bt_mesh_app_provision_server_configure(&provision_caps);

        // In case application forgot to fill config.oob.
        if (static_oob_data_len != 0 && mesh_config.oob == 0)
        {
            mesh_config.oob = (WICED_BT_MESH_CORE_OOB_BIT_OTHER | WICED_BT_MESH_CORE_OOB_BIT_NUMBER);
        }
    }
    else
#endif
    // If SECURE_PROVISIONING is not specified, or static OOB data that has not been read from the static section
    // don't register callback and try to provision with no oob data
    {
    wiced_bt_mesh_app_provision_server_init(pb_priv_key, NULL);
    }

#ifdef MESH_DFU_SUPPORTED
    mesh_app_dfu_init();
#endif

    if (wiced_bt_mesh_app_func_table.p_mesh_app_init)
    {
        wiced_bt_mesh_app_func_table.p_mesh_app_init(node_authenticated);
    }
    // Now start mesh picking up tx power set by app in wiced_bt_mesh_core_adv_tx_power
    wiced_bt_mesh_core_start();
    mesh_util_print_heap_usage();
    WICED_BT_TRACE("## mesh_application_init done ##\r\n");
}

#ifdef WICEDX_LINUX
// This function is called when application wants to turn off mesh
void mesh_application_deinit(void)
{
    if (wiced_bt_mesh_app_func_table.p_mesh_app_init)
    {
        wiced_bt_mesh_app_func_table.p_mesh_app_init(WICED_FALSE);
    }
    wiced_bt_ble_observe(WICED_FALSE, 0, NULL);
    wiced_bt_mesh_core_shutdown();
}
#endif


#include "cy_smif.h"
// Handle received adv packet
CY_RAMFUNC_BEGIN
static void mesh_adv_report(wiced_bt_ble_scan_results_t *p_scan_result, uint8_t *p_adv_data)
{
    //wiced_bool_t processed = WICED_FALSE;

    if (p_scan_result == NULL)
        return;

#ifdef NEW_WICED_STACK
    /* New WICED stack puts the total ADV data length as the first byte - skip it for mesh. */
    p_adv_data++;
#endif

    if (p_scan_result->ble_evt_type == BTM_BLE_EVT_CONNECTABLE_ADVERTISEMENT)
    {
        // if we do not want to provision new devices over GATT, only pass nonconnectable adverts to RPR
#if defined REMOTE_PROVISION_SERVER_SUPPORTED && defined REMOTE_PROVISION_OVER_GATT_SUPPORTED
        if (wiced_bt_mesh_remote_provisioning_connectable_adv_packet(p_scan_result, p_adv_data))
            return;
#endif
#if defined GATT_PROXY_CLIENT_SUPPORTED
        wiced_bt_mesh_gatt_client_process_connectable_adv(p_scan_result->remote_bd_addr, p_scan_result->ble_addr_type, p_scan_result->rssi, p_adv_data);
#endif
    }
    else if (p_scan_result->ble_evt_type == BTM_BLE_EVT_SCAN_RSP)
    {
#if defined REMOTE_PROVISION_SERVER_SUPPORTED && defined REMOTE_PROVISION_OVER_GATT_SUPPORTED
        if (wiced_bt_mesh_remote_provisioning_scan_rsp(p_scan_result, p_adv_data))
            return;
#endif
    }
    else if (p_scan_result->ble_evt_type == BTM_BLE_EVT_NON_CONNECTABLE_ADVERTISEMENT)
    {
        if (p_non_conn_adv_handler != NULL)
        {
            if ((*p_non_conn_adv_handler)(p_scan_result->rssi, p_adv_data, p_scan_result->remote_bd_addr))
                return;
        }
#if REMOTE_PROVISION_SERVER_SUPPORTED
        if (wiced_bt_mesh_remote_provisioning_nonconnectable_adv_packet(p_scan_result, p_adv_data))
            return;
#endif // if defined REMOTE_PROVISION_SERVER_SUPPORTED
#ifdef PRIVATE_PROXY_SUPPORTED
        if (wiced_bt_mesh_proxy_solicitation_nonconnectable_adv_packet(p_scan_result, p_adv_data))
            return;
#endif // if defined PRIVATE_PROXY_SUPPORTED

        wiced_bt_mesh_core_adv_packet(p_scan_result->rssi, p_adv_data, p_scan_result->remote_bd_addr);
    }
}
CY_RAMFUNC_END

#if 0
// Default interrupt processing.  If application does not want to reset on the application
// button press it shall provide p_mesh_app_hw_init function during initialization and provide its
// own interrupt processing
void mesh_interrupt_handler(void* user_data, uint8_t pin)
{
#if !defined (WICEDX_LINUX) && !defined (MESH_HOST_MODE)
    static uint64_t push_time;  //time of the push interrupt
    uint64_t curr_time;
    uint32_t value = wiced_hal_gpio_get_pin_input_status(pin);

    curr_time = wiced_bt_mesh_core_get_tick_count();
    //WICED_BT_TRACE("interrupt_handler: pin:%d value:%d time:%d\n", pin, value, curr_time);

    // On push just remember current time.
#if !defined(CYW43012C0) && !defined(CYW20706A2) && !defined(CYW20719B0) && !defined (MESH_HOST_MODE)
    if (value == platform_button[WICED_PLATFORM_BUTTON_1].button_pressed_value)
#else
    if (value == 0)
#endif
        push_time = curr_time;
    else if(curr_time >= (push_time + 3000))
    {
        // On release button with delay >= 3 seconds do factory reset
        mesh_application_factory_reset();
#ifdef MESH_HOMEKIT_COMBO_APP
        homekit_factory_reset();
#endif
    }
    else
    {
        // On release button with delay < 3 seconds just print message and do nothing.
        WICED_BT_TRACE("push and hold for 3 seconds to reset\n");
    }
#endif
}
#endif

/*
 * Application provided function to read/write information from/into NVRAM
 */
static uint32_t mesh_nvram_access(wiced_bool_t write, int inx, uint8_t* node_info, uint16_t len, wiced_result_t *p_result)
{
    uint32_t len_res = len;

#ifdef MESH_NVRAM_NOT_SUPPORTED
    *p_result = 0;
    if (write)
        return len;
    else
        return 0;
#else
#ifdef MESH_APPLICATION_MCU_MEMORY
    if (!write)
        len_res = mesh_application_mcu_memory_read(inx, len, node_info);
    else
        len_res = mesh_application_mcu_memory_write(inx, len, node_info);
    *p_result = 0;
#else

#if SIMULATED_NVRAM
    if (!write)
        len_res = (uint32_t)simulated_nvram_read(inx, len, (uint8_t*)node_info);
    // 0 len means delete
    else if (len != 0)
        //len_res = wiced_hal_write_nvram(inx, len, node_info, p_result);
    len_res = simulated_nvram_write(inx, len, (uint8_t*)node_info);
    else
        *p_result = (wiced_result_t)simulated_nvram_delete(inx);

    *p_result = 0;

#else
    if (!write)
        len_res = wiced_hal_read_nvram(inx, len, node_info, p_result);
    // 0 len means delete
    else if (len != 0)
    {
        len_res = wiced_hal_write_nvram(inx, len, node_info, p_result);
    }
    else
        wiced_hal_delete_nvram(inx, p_result);

#endif
#endif
#endif
    //WICED_BT_TRACE("mesh_nvram_access: inx:%x write:%d result:%x len:%d/%d\n", inx, write, *p_result, len, len_res);
    return len_res;
}


/**
* \brief Callback function to invoke a self test procedure of an Element.
* \details Application implements that function to support Health Server Model
* Called by core to get Current Fault.
*
* @param[in]   element             :Index of the elemnt
* @param[in]   test_id             :Identifier of a specific test to be performed
* @param[in]   company_id          :Company ID of the test
* @param[in]   fault_array_size    :Size of the buffer fault_array
* @param[out]  fault_array         : to receive FaultArray
*
* @return      number of error codes filled into fault_array
*/
static uint8_t mesh_fault_test(uint8_t element, uint8_t test_id, uint16_t company_id, uint8_t fault_array_size, uint8_t *fault_array)
{
    uint8_t     ret = 0;
    WICED_BT_TRACE("mesh_fault_test: element:%d test_id:%d company_id:%x\n", element, test_id, company_id);
    // We support only test_id 0 and company ID from composition data(Cypress). It corresponds to the PTS default valid test ids
    if (test_id != 0 || company_id != mesh_config.company_id)// MESH_COMPANY_ID_CYPRESS)
        return 0xff;
    if (fault_array_size--)
        fault_array[ret++] = 0x01;
    if (fault_array_size--)
        fault_array[ret++] = 0x02;
    if (fault_array_size--)
        fault_array[ret++] = 0x03;
    return ret;
}

/*
 * Returns the status of the Provisioning status of the node.
 * Returns WICED_TRUE: If node is provisioned, WICED_FALSE: If node is not provisioned.
 */
wiced_bool_t mesh_app_node_is_provisioned(void)
{
    return node_authenticated;
}

// Application implements that function to get notified on the periodic publication event
// If period is set to 0, the publication needs to stop. Period between 1 and 0xFFFE indicates
// that Periodic Publication for the specified model is being changed.  Value 0xFFFF indicates
// that the value needs to be published now.
wiced_bool_t mesh_app_publication_callback(uint8_t elem_idx, uint16_t company_id, uint16_t model_id, uint16_t period)
{
    wiced_bt_mesh_core_received_msg_handler_t   p_message_handler = NULL;
    wiced_bt_mesh_event_t                       *p_event;
    uint8_t                                     idx_model;

    WICED_BT_TRACE("mesh_app_publication_callback: idx:%d company_id:%x model_id:%x period:%04x\n", elem_idx, company_id, model_id, period);

    if (period != 0xFFFF)
    {
        // Check if application wants to process periodic notifications
        if (wiced_bt_mesh_app_func_table.p_mesh_app_notify_period_set != NULL)
        {
            // core reports, period in 100ms. Convert to milliseconds to send to the app.
            return (wiced_bt_mesh_app_func_table.p_mesh_app_notify_period_set(elem_idx, company_id, model_id, period * 100));
        }
        // Let core handle periodic publications
        return WICED_FALSE;
    }
    if (elem_idx < mesh_config.elements_num)
    {
        // get message handler of specific model
        for (idx_model = 0; idx_model < mesh_config.elements[elem_idx].models_num; idx_model++)
        {
            if (company_id == mesh_config.elements[elem_idx].models[idx_model].company_id
                && model_id == mesh_config.elements[elem_idx].models[idx_model].model_id)
            {
                p_message_handler = (wiced_bt_mesh_core_received_msg_handler_t)mesh_config.elements[elem_idx].models[idx_model].p_message_handler;
                break;
            }
        }
    }
    if (p_message_handler)
    {
        // create event, 0 DST means get info from publication.  Create event will use opcode
        // WICED_BT_MESH_OPCODE_UNKNOWN which will be treated by the library as Get.
        if (NULL != (p_event = wiced_bt_mesh_create_event(elem_idx, company_id, model_id, 0, 0)))
        {
            if (p_message_handler(p_event, NULL, 0))
                return WICED_TRUE;
            wiced_bt_mesh_release_event(p_event);
        }
    }
    else
    {
        WICED_BT_TRACE(" ignored\n");
    }
    return WICED_FALSE;
}

/*
 * Application implements that function to handle received messages. Call each library that this device needs to support.
 */
wiced_bt_mesh_core_received_msg_handler_t mesh_app_message_handler_callback(uint16_t company_id, uint16_t opcode, uint16_t *p_model_id, uint8_t *p_rpl_delay)
{
    wiced_bt_mesh_core_received_msg_handler_t p_message_handler = NULL;
    uint8_t                                   idx_elem, idx_model;
    wiced_bt_mesh_event_t                     temp_event;
    uint16_t                                  model_id = 0xffff;

    WICED_BT_TRACE("company_id:%x opcode:%x\r\n", company_id, opcode);

    // Each model present on the element contains the callback which will be executed.
    // If message handler returns that callback, that means that Opcode is for that model.
    // The special case is Proxy Status messages, which do not belong to any model.
    if ((company_id == MESH_COMPANY_ID_UNUSED) && (p_proxy_status_message_handler != NULL))
    {
        p_message_handler = p_proxy_status_message_handler;
    }
    else
    {
        temp_event.company_id = company_id;
        temp_event.opcode = opcode;
        temp_event.model_id = 0xffff;   // it is a sign of special mode for model to just return true if the opcode is for that model, without message handling.
        temp_event.status.rpl_delay = 5;  // By default save RPL after 5 seconds delay to reduce number of NVRAM writes if messages are coming too fast

        for (idx_elem = 0; idx_elem < mesh_config.elements_num; idx_elem++)
        {
            for (idx_model = 0; idx_model < mesh_config.elements[idx_elem].models_num; idx_model++)
            {
                if (((company_id != MESH_COMPANY_ID_BT_SIG) && (mesh_config.elements[idx_elem].models[idx_model].company_id == MESH_COMPANY_ID_BT_SIG)) ||
                    ((company_id == MESH_COMPANY_ID_BT_SIG) && (mesh_config.elements[idx_elem].models[idx_model].company_id != MESH_COMPANY_ID_BT_SIG)))
                    continue;
                p_message_handler = (wiced_bt_mesh_core_received_msg_handler_t)mesh_config.elements[idx_elem].models[idx_model].p_message_handler;
                if (p_message_handler == NULL)
                    continue;
                temp_event.element_idx = idx_elem;
                if (!p_message_handler(&temp_event, NULL, 0))
                    continue;
                model_id = mesh_config.elements[idx_elem].models[idx_model].model_id;
                if (p_model_id)
                    *p_model_id = model_id;
                if (p_rpl_delay)
                    *p_rpl_delay = temp_event.status.rpl_delay;
                break;
            }
            if (idx_model < mesh_config.elements[idx_elem].models_num)
                break;
        }
        if (idx_elem >= mesh_config.elements_num)
            p_message_handler = NULL;
    }
    // Application may overwrite models library and receive raw core data.  Do not allow
    // to overwrite certain profiles though.
    if ((p_app_model_message_handler != NULL) &&
        ((company_id != MESH_COMPANY_ID_BT_SIG) ||
            ((model_id != WICED_BT_MESH_CORE_MODEL_ID_CONFIG_CLNT) &&
                (model_id != WICED_BT_MESH_CORE_MODEL_ID_REMOTE_PROVISION_SRV) &&
                (model_id != WICED_BT_MESH_CORE_MODEL_ID_REMOTE_PROVISION_CLNT) &&
                (model_id != WICED_BT_MESH_CORE_MODEL_ID_GENERIC_DEFTT_CLNT))))
    {
        p_message_handler = p_app_model_message_handler;
    }
    if (p_message_handler == NULL)
    {
        WICED_BT_TRACE("mesh message ignored\n");
    }
    return p_message_handler;
}

/*
 * Application implements that function to start/stop scanning as requested by the core
 */
void mesh_start_stop_scan_callback(wiced_bool_t start, wiced_bool_t is_scan_active)
{
    static wiced_bool_t started = WICED_FALSE;
    static wiced_bool_t active = WICED_FALSE;
    uint16_t local_addr = wiced_bt_mesh_core_get_local_addr();
    // WICED_BT_TRACE("scan callback: start:%d active:%d local_addr:%x pb_gatt:%d\n", start, is_scan_active, local_addr, pb_gatt_in_progress);

    if ((started == start) && (active == is_scan_active))
        return;

    // check if the request is to stop the scan, or scan type is different
    if ((started && !start) || (start && (active != is_scan_active)))
    {
        WICED_BT_TRACE("mesh scan observe stop\n");

        // request to stop scanning
        wiced_bt_ble_observe(0, 0, mesh_adv_report);

        started = WICED_FALSE;
        if (!start)
            return;
    }

#ifndef WICEDX_LINUX
    wiced_bt_cfg_scan_settings.scan_mode = is_scan_active ? BTM_BLE_SCAN_MODE_ACTIVE : BTM_BLE_SCAN_MODE_PASSIVE;
    wiced_bt_cfg_scan_settings.low_duty_scan_window = 96;
    // If node is LPN in unprovisioned state before PB-ADV start then use low duty scan to save the battery. High dury scan will be restores on PB-ADV start.
    if ((mesh_config.features & WICED_BT_MESH_CORE_FEATURE_BIT_LOW_POWER) != 0 && local_addr == 0 && !pb_gatt_in_progress)
        wiced_bt_cfg_scan_settings.low_duty_scan_window = 48;
#endif
    started = WICED_TRUE;
    active = is_scan_active;

    WICED_BT_TRACE("mesh scan observe start active:%d\n", active);
    wiced_bt_ble_observe(start, 0, mesh_adv_report);
}


static void mesh_state_changed_cb(wiced_bt_mesh_core_state_type_t type, wiced_bt_mesh_core_state_t *p_state)
{
    switch (type)
    {
    case WICED_BT_MESH_CORE_STATE_TYPE_CLR_RPL:
        // Clear RPL. On error do factory reset
        if(!mesh_application_rpl_clr())
            mesh_application_factory_reset();
        break;

    case WICED_BT_MESH_CORE_STATE_TYPE_SEQ:
        // save own SEQ or RPL entry. On error do factory reset
        if (!mesh_application_seq_save(&p_state->seq))
        {
            mesh_application_factory_reset();
            break;
        }

        // only provisioner client needs to send these events to MCU
        if (!mesh_config_client)
            break;

        //WICED_BT_TRACE("mesh_state_changed_cb: addr:%x seq:%x previous_iv_idx:%d\n", p_state->seq.addr, p_state->seq.seq, p_state->seq.previous_iv_idx);
#ifdef HCI_CONTROL
        if (mesh_notify_host_seq_change)
        mesh_app_hci_send_seq_changed(&p_state->seq);
#endif
        break;

    case WICED_BT_MESH_CORE_STATE_NODE_STATE:
        WICED_BT_TRACE("mesh_state_changed_cb: authenticated:%d provisioned:%d proxy_on:%d pb_adv:%d\n", node_authenticated, p_state->node_state.provisioned, p_state->node_state.proxy_on, p_state->node_state.pb_adv);
        // If node just got provisioned in the connected state then it is end of PB_GATT.
        // Make proxy advert interval 30 ms to make first connection more reliable - core will use this value to start advertising after disconnection.
        if (mesh_app_gatt_is_connected() && !node_authenticated && p_state->node_state.provisioned)
            wiced_bt_mesh_core_proxy_adv_interval = 48;

        pb_gatt_in_progress = p_state->node_state.pb_adv;
        // If node is LPN in unprovisioned state(!node_authenticated) then restart scan on PB-ADV start or on provisioning end to switch scan from low duty to high duty
        if ((mesh_config.features & WICED_BT_MESH_CORE_FEATURE_BIT_LOW_POWER) != 0
            && !node_authenticated
            && ((!p_state->node_state.provisioned && p_state->node_state.pb_adv) || p_state->node_state.provisioned))
        {
            mesh_start_stop_scan_callback(WICED_FALSE, WICED_FALSE);
            mesh_start_stop_scan_callback(WICED_TRUE, WICED_FALSE);
        }
        // exit if provisioned state is not changed
        if ((node_authenticated && p_state->node_state.provisioned)
            || (!node_authenticated && !p_state->node_state.provisioned))
            break;

        node_authenticated = p_state->node_state.provisioned;
#if defined(LOW_POWER_NODE) && (LOW_POWER_NODE == 1)
        if (node_authenticated)
        {
            // On end of provisioning start Fast Polling state by setting the stop time to the 30 seconds(MESH_APP_FAST_POLL_TIME) after current time.
            mesh_app_fast_polling_stop_time = wiced_bt_mesh_core_get_tick_count() + MESH_APP_FAST_POLL_TIME;
            WICED_BT_TRACE("Start Fast Polling state. fast_polling_stop_time:%d\n", (uint32_t)mesh_app_fast_polling_stop_time);
        }
        else
        {
            // On switching to unprovisioned state reset Fast Polling state
            mesh_app_fast_polling_stop_time = 0;
        }
#endif

#ifndef MESH_HOMEKIT_COMBO_APP
        mesh_app_gatt_db_init(node_authenticated);
#else // MESH_HOMEKIT_COMBO_APP
        mesh_provisioning_state_changed(p_state->node_state.provisioned);
#endif
        if (wiced_bt_mesh_app_func_table.p_mesh_app_init != NULL)
        {
            wiced_bt_mesh_app_func_table.p_mesh_app_init(node_authenticated);
        }
        break;

    case WICED_BT_MESH_CORE_STATE_LPN_FRIENDSHIP:
        WICED_BT_TRACE("mesh_state_changed_cb:LPN_FRIENDSHIP: established:%d addr:%x/%x\n", p_state->lpn.established, p_state->lpn.addr, wiced_bt_mesh_core_lpn_get_friend_addr());
#ifdef _DEB_LPN_RSP_TIME
        // In test mode On friendship establishment reset poll responces statistics
        if (p_state->lpn.established)
            low_power_poll_rsp_time_clear();
        else
        {
            // On friendship lost print poll responces statistics
            uint16_t sent_poll_count, total_updt_rcv_count, time_updt_rcv_counters_size, *p_time_updt_rcv_counters;
            low_power_poll_rsp_time_get_stats(&sent_poll_count, &total_updt_rcv_count, &time_updt_rcv_counters_size, &p_time_updt_rcv_counters);
            WICED_BT_TRACE("  sent_poll_count:%d total_updt_rcv_count:%d time_updt_rcv_counters_size:%d\n", sent_poll_count, total_updt_rcv_count, time_updt_rcv_counters_size);
            WICED_BT_TRACE_ARRAY(p_time_updt_rcv_counters, time_updt_rcv_counters_size * 2, "");
        }
#endif
        break;

    case WICED_BT_MESH_CORE_STATE_LPN_SCAN:
        // it can happen only on LPN with established friendship
        WICED_BT_TRACE("mesh_state_changed_cb:LPN_SCAN: scan:%d\n", p_state->lpn_scan);
#ifndef PTS
        mesh_start_stop_scan_callback(p_state->lpn_scan, WICED_FALSE);
#endif
#if 0   // Enable app timer in LPN test
        if (p_state->lpn_scan)
        {
            if (!wiced_is_timer_in_use(&mesh_app_timer))
            {
                wiced_start_timer(&mesh_app_timer, MESH_APP_TIMEOUT_IN_SECONDS);
            }
        }
#endif
        break;

    case WICED_BT_MESH_CORE_STATE_LPN_SLEEP:
#if defined(LOW_POWER_NODE) && (LOW_POWER_NODE == 1)
    {
        uint64_t curr_time = wiced_bt_mesh_core_get_tick_count();
        WICED_BT_TRACE("mesh_state_changed_cb:LPN_SLEEP: timeout:%d fast_polling_stop_time:%d curr_time:%d\n", p_state->lpn_sleep, (uint32_t)mesh_app_fast_polling_stop_time, (uint32_t)curr_time);
        // If we are in the Fast Polling state
        if (mesh_app_fast_polling_stop_time != 0)
        {
            // If Fast Polling state isn't expired yet
            if (mesh_app_fast_polling_stop_time > curr_time)
            {
                // If at least one access message is received since previous poll timeout (sleep) then extend Fast Polling state on 30 seconds(MESH_APP_FAST_POLL_TIME)
                wiced_bt_mesh_core_transport_statistics_t stats;
                wiced_bt_mesh_core_transport_statistics_get(&stats);
                wiced_bt_mesh_core_transport_statistics_reset();
                if (stats.received_access_layer_msg_cnt)
                    mesh_app_fast_polling_stop_time = curr_time + MESH_APP_FAST_POLL_TIME;
                // Keep 1 sec(MESH_APP_FAST_POLL_TIMEOUT) poll timeout in the Fast Polling state unless requested sleep time is less then 1 sec.
                if (p_state->lpn_sleep > MESH_APP_FAST_POLL_TIMEOUT)
                    p_state->lpn_sleep = MESH_APP_FAST_POLL_TIMEOUT;

                WICED_BT_TRACE("Fast Polling received_access_layer_msg_cnt\n", stats.received_access_layer_msg_cnt);
                break;
            }
            // Fast Polling state is expired. Reset Fast Polling state.
            mesh_app_fast_polling_stop_time = 0;
        }
    }
#else
        WICED_BT_TRACE("mesh_state_changed_cb:LPN_SLEEP: timeout:%d\n", p_state->lpn_sleep);
#endif
        if (wiced_is_timer_in_use(&mesh_app_timer))
        {
            wiced_stop_timer(&mesh_app_timer);
        }
        if (wiced_bt_mesh_app_func_table.p_mesh_app_lpn_sleep)
        {
            wiced_bt_mesh_app_func_table.p_mesh_app_lpn_sleep(p_state->lpn_sleep);
        }
        break;

    case WICED_BT_MESH_CORE_STATE_FRND_FRIENDSHIP:
        WICED_BT_TRACE("mesh_state_changed_cb:FRND_FRIENDSHIP: established:%d addr:%x\n", p_state->frnd.established, p_state->frnd.addr);
        break;

#ifdef PTS
    case WICED_BT_MESH_CORE_STATE_PRIVATE_BEACON:
#ifdef HCI_CONTROL
        mesh_app_hci_send_private_beacon(&p_state->beacon);
#endif
        break;

    case WICED_BT_MESH_CORE_STATE_PROXY_SERVICE_ADV:
#ifdef HCI_CONTROL
        mesh_app_hci_send_proxy_service_adv(&p_state->proxy_service);
#endif
        break;
#endif

    default:
        break;
    }
}

/*
 * The function goes through all models of all elements and returns number of elements on which specified model is present
 */
uint8_t mesh_get_number_of_elements(uint16_t model_id)
{
    uint8_t element_idx;
    uint8_t model_idx;
    uint8_t num_elements_with_model = 0;

    for (element_idx = 0; element_idx < mesh_config.elements_num; element_idx++)
    {
        for (model_idx = 0; model_idx < mesh_config.elements[element_idx].models_num; model_idx++)
        {
            if ((mesh_config.elements[element_idx].models[model_idx].company_id == MESH_COMPANY_ID_BT_SIG) &&
                (mesh_config.elements[element_idx].models[model_idx].model_id == model_id))
            {
                num_elements_with_model++;
                break;
            }
        }
    }
    return (num_elements_with_model);
}

#if defined(SECURE_PROVISIONING) || defined(CERTIFICATE_BASED_PROVISIONING_SUPPORTED)
/*
 * Process event received from the OnOff Client.
 */
void mesh_app_provision_message_handler(uint16_t event, void *p_data)
{
    switch (event)
    {
    case WICED_BT_MESH_PROVISION_STARTED:
        WICED_BT_TRACE("mesh app provision started\n");
        break;

    case WICED_BT_MESH_PROVISION_END:
        WICED_BT_TRACE("mesh app provision end addr:%04x result:%d\n", ((wiced_bt_mesh_provision_status_data_t *)p_data)->addr, ((wiced_bt_mesh_provision_status_data_t *)p_data)->result);
        break;

    case WICED_BT_MESH_PROVISION_GET_OOB_DATA:
        mesh_app_process_oob_get((wiced_bt_mesh_provision_device_oob_request_data_t *)p_data);
        break;
    default:
        WICED_BT_TRACE("mesh app provision unknown event\n");
    }
}

/*
 * This application supports Static OOB Data. This is the only type of request we should have received.
 */
void mesh_app_process_oob_get(wiced_bt_mesh_provision_device_oob_request_data_t *p_data)
{
    if (p_data->type != WICED_BT_MESH_PROVISION_GET_OOB_TYPE_GET_STATIC)
    {
        WICED_BT_TRACE("invalid OOB type:%d\n", p_data->type);
        return;
    }
    WICED_BT_TRACE("Get OOB static data len:%d\n", static_oob_data_len);
    wiced_bt_mesh_provision_set_oob(static_oob_data, static_oob_data_len);
}
#endif

void mesh_app_setup_nvram_ids()
{

	//Initialize SMP curve
	p_curve_p256 = &curve_p256;

	// Currently we can support up to 4 network keys.
	wiced_bt_mesh_core_net_key_max_num = 4;
	wiced_bt_mesh_core_app_key_max_num = 8;
	wiced_bt_mesh_scene_max_num = 10;
	wiced_bt_mesh_scheduler_events_max_num = 16; // PTS test uses index 15 (MMDL/SR/SCHS/BV-01-C )

    // Allocate one additional NVRAM ID for configuration data in case it will increased on FW upgrade
    uint16_t cfg_data_len = wiced_bt_mesh_get_node_config_size(&mesh_config) + WICED_BT_MESH_CORE_NVRAM_CHUNK_MAX_SIZE;

    wiced_bt_mesh_light_lc_nvram_id_start = WICED_NVRAM_VSID_END - mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_LIGHT_LC_SRV);
    wiced_bt_mesh_light_lc_run_nvram_id_start = wiced_bt_mesh_light_lc_nvram_id_start - mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_LIGHT_LC_SRV);
    wiced_bt_mesh_light_hsl_nvram_id_start = wiced_bt_mesh_light_lc_run_nvram_id_start - mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_LIGHT_HSL_SRV);
    wiced_bt_mesh_light_ctl_nvram_id_start = wiced_bt_mesh_light_hsl_nvram_id_start - mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_LIGHT_CTL_SRV);
    wiced_bt_mesh_light_xyl_nvram_id_start = wiced_bt_mesh_light_ctl_nvram_id_start - mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_LIGHT_XYL_SRV);
    wiced_bt_mesh_light_lightness_nvram_id_start = wiced_bt_mesh_light_xyl_nvram_id_start - mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_LIGHT_LIGHTNESS_SRV);
    wiced_bt_mesh_power_level_nvram_id_start = wiced_bt_mesh_light_lightness_nvram_id_start - mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_GENERIC_POWER_LEVEL_SRV);
    wiced_bt_mesh_power_onoff_nvram_id_start = wiced_bt_mesh_power_level_nvram_id_start - mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_GENERIC_POWER_ONOFF_SRV);
    wiced_bt_mesh_default_trans_time_nvram_id_start = wiced_bt_mesh_power_onoff_nvram_id_start      - mesh_get_number_of_elements(WICED_BT_MESH_CORE_MODEL_ID_GENERIC_DEFTT_SRV);;
    wiced_bt_mesh_scheduler_nvram_id_start = wiced_bt_mesh_default_trans_time_nvram_id_start - wiced_bt_mesh_scheduler_events_max_num;
    wiced_bt_mesh_scene_nvram_id_end = wiced_bt_mesh_scheduler_nvram_id_start - 1;
    wiced_bt_mesh_scene_nvram_id_start = wiced_bt_mesh_scene_nvram_id_end - wiced_bt_mesh_scene_max_num;
    wiced_bt_mesh_scene_register_nvram_id = wiced_bt_mesh_scene_nvram_id_start - 1;

    wiced_bt_mesh_core_nvm_idx_node_data = wiced_bt_mesh_scene_register_nvram_id - 1;
    wiced_bt_mesh_core_nvm_idx_virt_addr = wiced_bt_mesh_core_nvm_idx_node_data - 1;
    wiced_bt_mesh_core_nvm_idx_frnd_state = wiced_bt_mesh_core_nvm_idx_virt_addr - 1;
    wiced_bt_mesh_core_nvm_idx_net_key_begin = wiced_bt_mesh_core_nvm_idx_frnd_state - wiced_bt_mesh_core_net_key_max_num;
    wiced_bt_mesh_core_nvm_idx_app_key_begin = wiced_bt_mesh_core_nvm_idx_net_key_begin - wiced_bt_mesh_core_app_key_max_num;
    wiced_bt_mesh_core_nvm_idx_health_state = wiced_bt_mesh_core_nvm_idx_app_key_begin - 1;
    wiced_bt_mesh_core_nvm_idx_cfg_data = wiced_bt_mesh_core_nvm_idx_health_state - ((cfg_data_len + (WICED_BT_MESH_CORE_NVRAM_CHUNK_MAX_SIZE - 1)) / WICED_BT_MESH_CORE_NVRAM_CHUNK_MAX_SIZE);
    mesh_nvm_idx_seq                                = wiced_bt_mesh_core_nvm_idx_cfg_data       - 1;
#ifndef CYW20706A2
    wiced_bt_mesh_core_nvm_idx_fw_distributor       = mesh_nvm_idx_seq                          - 1000;
#endif
    // don't support Directed Forwarding on 20706
#ifndef CYW20706A2
    wiced_bt_mesh_core_nvm_idx_df_config            = mesh_nvm_idx_seq                          - 1000;
#endif

    WICED_BT_TRACE("mesh app setup nvram ids: net_key_max_num:%d app_key_max_num:%d nvm_idx_seq:%x %x-%x cfg_data_len:%d\n", wiced_bt_mesh_core_net_key_max_num, wiced_bt_mesh_core_app_key_max_num, mesh_nvm_idx_seq, wiced_bt_mesh_core_nvm_idx_health_state, WICED_NVRAM_VSID_END, cfg_data_len);
    WICED_BT_TRACE("mesh app node_data:%x net_key_begin:%x app_key_begin:%x\n", wiced_bt_mesh_core_nvm_idx_node_data, wiced_bt_mesh_core_nvm_idx_net_key_begin, wiced_bt_mesh_core_nvm_idx_app_key_begin);
}

wiced_bool_t mesh_application_seq_init(void)
{
    wiced_result_t      result;
#ifdef CYW20706A2
    uint32_t            len;
#else
    mesh_app_rpl_item_t rpl_item;
#endif
    uint8_t             *p;
    uint32_t            i, seq;


    //WICED_BT_TRACE("mesh_application_seq_init:node_authenticated:%d\n", node_authenticated);

    // if node is provisioned then read own SEQ and RPL size from NVRAM, update SEQ, save it in the NVRAM and set it to the node
    // otherwise just save 0-initialized value in NVRAM
    if (node_authenticated)
    {
        if (sizeof(mesh_app_rpl_init) != mesh_nvram_access(WICED_FALSE, mesh_nvm_idx_seq, (uint8_t*)&mesh_app_rpl_init, sizeof(mesh_app_rpl_init), &result) || result != 0)
            return WICED_FALSE;
        // add 1000 because we write only multiples of thousands values. It is not needed if node doesn't send messages often.
        mesh_app_rpl_init.seq += 1000;
    }
    if (sizeof(mesh_app_rpl_init) != mesh_nvram_access(WICED_TRUE, mesh_nvm_idx_seq, (uint8_t*)&mesh_app_rpl_init, sizeof(mesh_app_rpl_init), &result) || result != 0)
        return WICED_FALSE;
    if (!wiced_bt_mesh_core_set_seq(0, mesh_app_rpl_init.seq, WICED_FALSE))
        return WICED_FALSE;

    // read RPL items from NVRAM and set them to the node
#ifdef CYW20706A2
    // On 20706 RPL size is hardcoded.
    // Make sure size is correct
    if(mesh_app_rpl_init.size > mesh_config.replay_cache_size)
        return WICED_FALSE;
    //Allocate memory for full RPL and read RPL entries from the NVRAM
    mesh_app_rpl_items = (mesh_app_rpl_item_t*)wiced_memory_permanent_allocate(mesh_config.replay_cache_size * sizeof(mesh_app_rpl_item_t));
    // Read RPL if it isn't empty
    if (mesh_app_rpl_init.size != 0)
    {
        len = mesh_app_rpl_init.size * sizeof(mesh_app_rpl_item_t);
        if (len != mesh_nvram_access(WICED_FALSE, mesh_nvm_idx_seq - 1, (uint8_t*)mesh_app_rpl_items, len, &result) || result != 0)
            return WICED_FALSE;
    }
    // Set RPL into the core lib
    for (i = 0; i < mesh_app_rpl_init.size; i++)
    {
        p = mesh_app_rpl_items[i].seq;
        STREAM_TO_UINT24(seq, p);
        if (!wiced_bt_mesh_core_set_seq(mesh_app_rpl_items[i].addr & (~MESH_APP_RPL_ITEM_PREV_IVI_FLAG), seq, (mesh_app_rpl_items[i].addr & MESH_APP_RPL_ITEM_PREV_IVI_FLAG) != 0 ? WICED_TRUE : WICED_FALSE))
            return WICED_FALSE;
    }
#else
    for (i = 0; i < mesh_app_rpl_init.size; i++)
    {
        if (sizeof(rpl_item) != mesh_nvram_access(WICED_FALSE, mesh_nvm_idx_seq - 1 - i, (uint8_t*)&rpl_item, sizeof(rpl_item), &result) || result != 0)
            continue;
        p = rpl_item.seq;
        STREAM_TO_UINT24(seq, p);
        if (!wiced_bt_mesh_core_set_seq(rpl_item.addr & (~MESH_APP_RPL_ITEM_PREV_IVI_FLAG), seq, (rpl_item.addr & MESH_APP_RPL_ITEM_PREV_IVI_FLAG) != 0 ? WICED_TRUE : WICED_FALSE))
            return WICED_FALSE;
    }
#endif
    return WICED_TRUE;
}

// saves own SEQ or RPL entry
wiced_bool_t mesh_application_rpl_clr(void)
{
    wiced_result_t          result;
    WICED_BT_TRACE("Clear RPL: size:%d\n", mesh_app_rpl_init.size);
    mesh_app_rpl_init.size = 0;
    if (sizeof(mesh_app_rpl_init) != mesh_nvram_access(WICED_TRUE, mesh_nvm_idx_seq, (uint8_t*)&mesh_app_rpl_init, sizeof(mesh_app_rpl_init), &result) || result != 0)
        return WICED_FALSE;
    return WICED_TRUE;
}

// saves own SEQ or RPL entry
wiced_bool_t mesh_application_seq_save(wiced_bt_mesh_core_state_seq_t *p_seq)
{
    wiced_result_t          result;

    // WICED_BT_TRACE("Save SRC:%x SEQ:%d prev_ivi:%d idx:%d rpl_size:%d\n", p_seq->addr, p_seq->seq, p_seq->previous_iv_idx, p_seq->rpl_entry_idx, mesh_app_rpl_init.size);

    // if it is own SEQ then save it into NVRAM
    if (p_seq->addr == 0)
    {
        // write only multiples of thousands values to prevent too often NVRAM writes. Write each change if node doesn't send messages often.
        mesh_app_rpl_init.seq = p_seq->seq;
        if ((mesh_app_rpl_init.seq % 1000) == 0)
        {
            if (sizeof(mesh_app_rpl_init) != mesh_nvram_access(WICED_TRUE, mesh_nvm_idx_seq, (uint8_t*)&mesh_app_rpl_init, sizeof(mesh_app_rpl_init), &result) || result != 0)
                return WICED_FALSE;
        }
    }
    else if (p_seq->addr == 0xffff)
    {
        // 0xffff means delete all RPL entries - all other fields are ignored in that case.
        mesh_app_rpl_init.size = 0;
        if (sizeof(mesh_app_rpl_init) != mesh_nvram_access(WICED_TRUE, mesh_nvm_idx_seq, (uint8_t*)&mesh_app_rpl_init, sizeof(mesh_app_rpl_init), &result) || result != 0)
            return WICED_FALSE;
    }
    else
    {
        // save RPL entry
        uint8_t                 *p;
#ifdef CYW20706A2
        uint32_t                len;
        mesh_app_rpl_item_t     *p_rpl_item;

        // On 20706 RPL size is hardcoded. Make sure index is inside that size
        if (p_seq->rpl_entry_idx >= mesh_config.replay_cache_size)
            return WICED_FALSE;

        // If new record has to be added
        if (p_seq->rpl_entry_idx >= mesh_app_rpl_init.size)
        {
            // delete (set invalid group address 0x8000) probably existing records for unknown indices. It is possible because we save RPL entries on successfull message handling
            while (mesh_app_rpl_init.size < p_seq->rpl_entry_idx)
                mesh_app_rpl_items[mesh_app_rpl_init.size++].addr = 0x8000;
            mesh_app_rpl_init.size = p_seq->rpl_entry_idx + 1;
            // update RPL_INIT NVRAM data with new RPL size
            if (sizeof(mesh_app_rpl_init) != mesh_nvram_access(WICED_TRUE, mesh_nvm_idx_seq, (uint8_t*)&mesh_app_rpl_init, sizeof(mesh_app_rpl_init), &result) || result != 0)
                return WICED_FALSE;
        }

        p_rpl_item = &mesh_app_rpl_items[p_seq->rpl_entry_idx];
        p_rpl_item->addr = p_seq->addr;
        if (p_seq->previous_iv_idx)
            p_rpl_item->addr |= MESH_APP_RPL_ITEM_PREV_IVI_FLAG;
        p = p_rpl_item->seq;
        UINT24_TO_STREAM(p, p_seq->seq);
        len = mesh_app_rpl_init.size * sizeof(mesh_app_rpl_item_t);
        if (len != mesh_nvram_access(WICED_TRUE, mesh_nvm_idx_seq - 1, (uint8_t*)mesh_app_rpl_items, len, &result) || result != 0)
            return WICED_FALSE;
#else
        mesh_app_rpl_item_t     rpl_item;
        rpl_item.addr = p_seq->addr;
        if (p_seq->previous_iv_idx)
            rpl_item.addr |= MESH_APP_RPL_ITEM_PREV_IVI_FLAG;
        p = rpl_item.seq;
        UINT24_TO_STREAM(p, p_seq->seq);
        if (sizeof(rpl_item) != mesh_nvram_access(WICED_TRUE, mesh_nvm_idx_seq - 1 - p_seq->rpl_entry_idx, (uint8_t*)&rpl_item, sizeof(rpl_item), &result) || result != 0)
            return WICED_FALSE;
        // If new record is added
        if (p_seq->rpl_entry_idx >= mesh_app_rpl_init.size)
        {
            // delete probably existing records for unknown indices. It is possible because we save RPL entries on successfull message handling
            while (mesh_app_rpl_init.size < p_seq->rpl_entry_idx)
                if (0 == mesh_nvram_access(WICED_TRUE, mesh_nvm_idx_seq - 1 - mesh_app_rpl_init.size++, NULL, 0, &result)) // that if is useless - just to use return result to get rid of coverity error
                    result = 0;
            // update RPL_INIT NVRAM data with new RPL size
            if (sizeof(mesh_app_rpl_init) != mesh_nvram_access(WICED_TRUE, mesh_nvm_idx_seq, (uint8_t*)&mesh_app_rpl_init, sizeof(mesh_app_rpl_init), &result) || result != 0)
                return WICED_FALSE;
        }
#endif
    }
    return WICED_TRUE;
}

/**
 *@brief Returns the first usable NVRAM Identifier.
 * Application can use the NVRAM IDs starting from returned value.
**/
uint16_t mesh_application_get_nvram_id_app_start(void)
{
    return NVRAM_ID_APP_START;
}


/**
 *@brief Returns the device uuid.
**/
uint8_t* mesh_application_get_device_uuid(void)
{
    return device_uuid;
}


/**
 *@brief Register an application dependent non-connectable adv packet handler
 * Register an application dependent non-connectable adv packet handler
**/
void mesh_application_reg_non_conn_adv_handler(wiced_bt_mesh_app_non_conn_adv_handler_t handler)
{
    p_non_conn_adv_handler = handler;
}

// converts 6 bits of bin value to base 64 character (A-Z,a-z,0-9,+,/)
uint8_t wiced_bt_mesh_base64_encode_6bits(uint8_t bin)
{
    uint8_t res = (uint8_t)'/';
    if (bin <= 0x19)
        res = bin + (uint8_t)'A';
    else if (bin <= 0x33)
        res = bin - 0x1a + (uint8_t)'a';
    else if (bin <= 0x3d)
        res = bin - 0x34 + (uint8_t)'0';
    else if (bin == 0x3e)
        res = (uint8_t)'+';
    return res;
}

void mesh_app_timer_init(void)
{
    /* Starting the app timer  */
    memset(&mesh_app_timer, 0, sizeof(wiced_timer_t));
    if (wiced_init_timer(&mesh_app_timer,(wiced_timer_callback_t *) mesh_app_timer_callback, 0u, WICED_SECONDS_PERIODIC_TIMER) == WICED_SUCCESS)
    {
        if (wiced_start_timer(&mesh_app_timer, MESH_APP_TIMEOUT_IN_SECONDS) != WICED_SUCCESS)
        {
            WICED_BT_TRACE("APP START Timer FAILED!!\n");
        }
    }
    else
    {
        WICED_BT_TRACE("APP INIT Timer FAILED!!\n");
    }
}

#ifdef _DEB_PRINT_BUF_USE
// dump wiced bt buffer statistics on every 10 seconds to monitor buffer usage
void deb_print_buf_use()
{
    wiced_bt_buffer_statistics_t buff_stat[4];
    wiced_bt_get_buffer_usage(buff_stat, sizeof(buff_stat));
    WICED_BT_TRACE("pool size/cur/max/total %d/%d/%d/%d %d/%d/%d/%d %d/%d/%d/%d %d/%d/%d/%d\n",
        buff_stat[0].pool_size, buff_stat[0].current_allocated_count, buff_stat[0].max_allocated_count, buff_stat[0].total_count,
        buff_stat[1].pool_size, buff_stat[1].current_allocated_count, buff_stat[1].max_allocated_count, buff_stat[1].total_count,
        buff_stat[2].pool_size, buff_stat[2].current_allocated_count, buff_stat[2].max_allocated_count, buff_stat[2].total_count,
        buff_stat[3].pool_size, buff_stat[3].current_allocated_count, buff_stat[3].max_allocated_count, buff_stat[3].total_count);
}
#endif

#ifdef _DEB_PRINT_MESH_STATS

// Counting number of transmitted ext-ADVs in the interval of _DEB_PRINT_MESH_STATS on
extern uint32_t mesh_num_transmitted_advs;

// dump mesh statistics on every _DEB_PRINT_MESH_STATS
void deb_print_mesh_stats()
{
    wiced_bt_mesh_core_statistics_t network_stats;
    wiced_bt_mesh_core_transport_statistics_t transport_stats;
    wiced_bt_mesh_core_statistics_get(&network_stats);
    wiced_bt_mesh_core_transport_statistics_get(&transport_stats);
    wiced_bt_mesh_core_statistics_reset();
    wiced_bt_mesh_core_transport_statistics_reset();
    WICED_BT_TRACE("rcv msg cnt:total/proxy-cfg/relay/u-cast/group/lpn:       %d/%d/%d/%d/%d/%d\n",
        network_stats.received_msg_cnt, network_stats.received_proxy_cfg_msg_cnt, network_stats.relayed_msg_cnt,
        network_stats.accepted_unicast_msg_cnt, network_stats.accepted_group_msg_cnt, network_stats.received_for_lpn_msg_cnt);
    WICED_BT_TRACE("dropped msg cnt:invalid/nid/decr/cache/relay-ttl/group:   %d/%d/%d/%d/%d/%d\n",
        network_stats.dropped_invalid_msg_cnt, network_stats.dropped_by_nid_msg_cnt, network_stats.dropped_not_decrypted_msg_cnt,
        network_stats.dropped_by_net_cache_msg_cnt, network_stats.not_relayed_by_ttl_msg_cnt, network_stats.dropped_group_msg_cnt);
    WICED_BT_TRACE("sent msg cnt: adv/gatt/proxy_cfg/clnt/net-cred/frnd-cred: %d/%d/%d/%d/%d/%d\n",
        network_stats.sent_adv_msg_cnt, network_stats.sent_gatt_msg_cnt, network_stats.sent_proxy_cfg_msg_cnt,
        network_stats.sent_proxy_clnt_msg_cnt, network_stats.sent_net_credentials_msg_cnt, network_stats.sent_frnd_credentials_msg_cnt);
    WICED_BT_TRACE("sent msg cnt: u-cast/group/access/unseg/seg/ack: %d/%d/%d/%d/%d/%d\n",
        network_stats.sent_adv_unicast_msg_cnt, network_stats.sent_adv_group_msg_cnt,
        transport_stats.sent_access_layer_msg_cnt, transport_stats.sent_unseg_msg_cnt, transport_stats.sent_seg_msg_cnt,
        transport_stats.sent_ack_msg_cnt);
    WICED_BT_TRACE("rcv msg cnt: access/unseg/seg/ack/dropped access: %d/%d/%d/%d\n",
        transport_stats.received_access_layer_msg_cnt, transport_stats.received_unseg_msg_cnt, transport_stats.received_seg_msg_cnt,
        transport_stats.received_ack_msg_cnt, transport_stats.dropped_access_layer_msg_cnt);

    // Counting number of transmitted ext-ADVs in the interval of _DEB_PRINT_MESH_STATS on 20829 and reset to 0
    WICED_BT_TRACE("mesh_num_transmitted_advs: %d\n", mesh_num_transmitted_advs);
    mesh_num_transmitted_advs = 0;

    mesh_util_print_heap_usage();
}
#endif


// App timer event handler
static void mesh_app_timer_callback(wiced_timer_callback_t arg)
{
    static uint32_t app_timer_count = 1;
    app_timer_count++;

#ifdef _DEB_PRINT_BUF_USE
    /* dump wiced bt buffer statistics on every 10 seconds to monitor buffer usage */
    if (!(app_timer_count % _DEB_PRINT_BUF_USE))
    {
        deb_print_buf_use();
    }
#endif
#ifdef _DEB_PRINT_MESH_STATS
    // dump mesh statistics on every _DEB_PRINT_MESH_STATS
    if ((app_timer_count % _DEB_PRINT_MESH_STATS) == 2)
    {
        deb_print_mesh_stats();
    }
#endif
}

#if 0
// Functions for testing the delay between poll and response (friend update)
void low_power_poll_rsp_time_clear(void);
void low_power_poll_rsp_time_get_stats(
    uint16_t* p_sent_poll_count,
    uint16_t* p_total_updt_rcv_count,
    uint16_t* p_time_updt_rcv_counters_size,
    uint16_t** pp_time_updt_rcv_counters);
#endif


uint8_t *mesh_app_alloc_buffer(int len)
{
    uint8_t *p_buf = wiced_bt_get_buffer(len);
#if defined(WICED_BT_MESH_TRACE_ENABLE)
    WICED_BT_TRACE("mesh_app_alloc_buffer %d 0x%x \r\n", len, p_buf);
#endif
    return p_buf;
}

void mesh_app_free_buffer(uint8_t *p_buf)
{
#if defined(WICED_BT_MESH_TRACE_ENABLE)
    WICED_BT_TRACE("mesh_app_free_buffer 0x%x \r\n", p_buf);
#endif
    wiced_bt_free_buffer(p_buf);
    return;
}
